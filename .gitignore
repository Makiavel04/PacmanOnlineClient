 J'ai ces fichiers, mais je ne sais pas si c'est bon de mettre les panels a part de la frame, puisque que je dois pouvoir appeler le controleur en fonction de mes actions. Or mes panels n'ont pas le controleur et je ne sais pas si bonne idee de lui donné

C'est une excellente question d'architecture. Actuellement, ton code utilise le Design Pattern State (État), ce qui est une très bonne base pour gérer la navigation d'une application Java Swing.

Pour répondre à ton inquiétude : Non, il n'est pas nécessaire (et même déconseillé) de donner le contrôleur directement à chaque panel. Cela créerait un couplage trop fort.

Voici comment structurer les choses proprement en suivant la logique de ton projet :
1. Pourquoi ton architecture actuelle est déjà sur la bonne voie

Dans ton code, les panels interagissent avec l'objet Etat via vue.getEtat(). C'est l'État qui décide de la logique de transition.

    Le Panel s'occupe de l'affichage et de la capture de l'événement (clic bouton).

    L'État s'occupe de la logique métier de navigation.

    Le Contrôleur (que possède déjà VueClient) doit s'occuper de la logique "réseau" ou "données".

2. La solution : Passer par la VueClient

Puisque chaque panel possède une référence vers VueClient (ton objet vue), et que VueClient possède déjà le controleur, la solution la plus propre est de créer des méthodes de "pont" dans VueClient ou d'appeler le contrôleur directement depuis les classes Etat.
Option A : L'État pilote le contrôleur (Recommandé)

L'État est le "cerveau" du moment. C'est lui qui devrait dire au contrôleur quoi faire.
Java

// Dans une classe Etat (ex: EtatConnecte.java)
@Override
public void rejoindrePartie() {
    // 1. On demande au contrôleur d'envoyer la requête réseau
    this.vue.getControleur().envoyerRequeteRejoindre(); 
    
    // 2. On change l'affichage seulement si nécessaire ou après confirmation
    this.vue.setEtat(new EtatEnAttentePartie(this.vue));
}

Note : Tu devras ajouter un getter pour le contrôleur dans VueClient.java.
Option B : Le "Médiateur" dans la Vue

Si tu veux centraliser, tu peux ajouter des méthodes dans VueClient :
Java

// Dans VueClient.java
public void actionSeConnecter() {
    this.controleur.tentativeConnexion();
}

Puis dans ton panel :
Java

// Dans PanelConnection.java
boutonConnection.addActionListener(e -> {
    vue.getEtat().seConnecter(); // L'état gère la transition
    // OU
    vue.actionSeConnecter(); // La vue fait le lien avec le contrôleur
});

3. Schéma de la communication

    Utilisateur clique sur le bouton dans PanelConnection.

    Panel appelle vue.getEtat().seConnecter().

    L'objet EtatInit appelle vue.getControleur().connecter(user, mdp).

    L'objet EtatInit change l'état de la vue vers new EtatConnecte(vue).

    EtatConnecte change automatiquement le panel affiché dans la frame.

Ce que je te conseille de modifier :

    Ajoute un getter dans VueClient.java pour accéder au contrôleur :
    Java

    public ControleurClient getControleur() {
        return this.controleur;
    }

    Ne donne pas le contrôleur aux Panels. Ils n'ont besoin que de la VueClient pour notifier que l'utilisateur a fait une action.

    Gère la logique dans tes États. Si "Se connecter" échoue (parce que le serveur est éteint), c'est l'état qui décidera de ne pas passer à l'écran suivant ou d'afficher un message d'erreur.

Souhaites-tu que je te montre comment modifier l'un de tes fichiers Etat pour intégrer un appel au contrôleur proprement ?

Le probleme, c'est que parfois, je dois attendre une reponse du controleur donc mettre cela dans les etat peut etre genant. Plutot passer par des ponts dans la vue

C'est une analyse très pertinente. Si ton contrôleur doit effectuer des appels réseau (sockets) ou des traitements asynchrones, bloquer la transition d'état en attendant une réponse dans le constructeur de l'État figerait ton interface graphique (EDT - Event Dispatch Thread).

Passer par des "ponts" (méthodes déléguées) dans la VueClient est effectivement une approche plus souple. Cela permet à la Vue de jouer le rôle de Médiateur.
1. Pourquoi l'approche par "Ponts" est préférable

En centralisant les appels au contrôleur dans VueClient, tu simplifies tes panels et tes états :

    Les Panels ne connaissent que la Vue et déclenchent des intentions d'action.

    La Vue transmet l'ordre au Contrôleur.

    Le Contrôleur, une fois qu'il reçoit la réponse du serveur (asynchrone), rappelle la Vue pour lui dire de changer d'État.

2. Mise en pratique de l'architecture

Voici comment tu peux structurer cela pour que ce soit propre :
Dans VueClient.java

Ajoute des méthodes qui font le lien. La Vue devient le point d'entrée de tous les événements.
Java

public class VueClient {
    // ... (attributs existants)

    // Pont pour la connexion
    public void requeteConnexion() {
        // On délègue au contrôleur
        this.controleur.seConnecter(); 
    }

    // Le contrôleur appellera cette méthode quand le serveur aura répondu "OK"
    public void transitionVersConnecte() {
        this.setEtat(new EtatConnecte(this));
    }

    public ControleurClient getControleur() {
        return this.controleur;
    }
}

Dans tes Panels

Tes panels restent simples. Ils ne font qu'appeler une méthode de l'état ou de la vue. Si tu veux vraiment découpler, tu peux même bypasser l'état pour les requêtes :
Java

// Exemple dans PanelConnection.java
boutonConnection.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent e){
        // La vue lance la requête via le contrôleur
        vue.requeteConnexion(); 
    }
});

3. Gestion de l'attente (Asynchronisme)

Le vrai avantage de cette méthode, c'est que tu peux gérer un état visuel "Chargement..." facilement :

    Utilisateur clique sur "Se connecter".

    Vue appelle controleur.seConnecter().

    Vue (optionnel) affiche un petit message "Connexion en cours...".

    Contrôleur reçoit la réponse du socket sur un thread séparé.

    Contrôleur utilise SwingUtilities.invokeLater() pour appeler vue.transitionVersConnecte().

Résumé de la structure recommandée
Composant	Rôle
Panel	Affiche les boutons et appelle vue.actionX() lors d'un clic.
VueClient	Possède le Controleur et l' Etat. Sert de hub de communication.
Etat	Définit quel Panel est actuellement affiché dans la Frame.
Contrôleur	Gère la logique métier et réseau, puis notifie la Vue des changements.

Cela évite que tes objets Etat ne deviennent trop complexes en essayant de gérer des réponses réseaux qu'ils ne devraient pas avoir à traiter.

Est-ce que tu veux que je t'aide à réécrire la méthode de VueClient pour qu'elle puisse recevoir les notifications de ton ControleurClient ?

package Vue;


import javax.swing.JFrame;

import javax.swing.JPanel;

import java.awt.event.WindowAdapter;

import java.awt.event.WindowEvent;


import Controller.ControleurClient;

import Etat.Etat;

import Etat.EtatInit;


public class VueClient {

JFrame frame;

JPanel panel;

ControleurClient controleur;


Etat etat;


public VueClient(ControleurClient controleur){

this.frame = new JFrame("Client Pacman");

this.frame.setSize(800,600);

//this.frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//Fermer l'application quand on clique sur la croix

this.frame.addWindowListener(new WindowAdapter() {

@Override

public void windowClosing(WindowEvent e) {

// Informe le controller que la fenêtre ferme

controleur.fermerConnexion(); // ferme proprement le socket, threads, etc.


frame.dispose();// remplace le EXIT_ON_CLOSE

}

});



this.etat = new EtatInit(this);



this.frame.setVisible(true);

}


public void setEtat(Etat etat){

this.etat = etat;

}

public Etat getEtat(){

return this.etat;

}


public void changerAffichage(JPanel panel){

if(this.panel != null){

this.frame.remove(this.panel);

}

this.panel = panel;

this.frame.add(this.panel);

this.frame.revalidate();

this.frame.repaint();

}


public void demanderAuthentification(String nom, String motDePasse){

this.controleur.demanderAuthentification(nom, motDePasse);

}

}

import java.io.IOException;

import java.net.ServerSocket;

import java.net.Socket;

import java.util.Vector;


public class ControllerServeur {

private static int port = 8080;

private static ServerSocket ecoute;

private static Socket so;

private static Vector<ClientHandlerThread> clients;


// public ControllerServeur(int p){

// this.port = p;

// this.clients = new Vector<ClientHandlerThread>();

// }


public static void main(String[] argu){

try {

ecoute = new ServerSocket(port); // on crée le serveur

clients = new Vector<ClientHandlerThread>();

System.out.println("serveur mis en place ");

while (true) {// le serveur va attendre qu’une connexion arrive

so = ecoute.accept(); // accepte une connexion

ClientHandlerThread clientThread;

synchronized(ControllerServeur.class){

clientThread = new ClientHandlerThread(so);//Crée un thread pour gérer le client a part et permettre au thread principal d'accueillir de nouveaux clients

clients.add(clientThread);

}

clientThread.start();

}

} catch (IOException e) {

System.out.println("problème\n"+ e);

}

}


public static synchronized void notifierMessage(String expediteur, String contenu){

for(ClientHandlerThread client : clients){

client.newMessage(expediteur, contenu);

}

}


public static synchronized void disconnectThread(long idThread){

// Recherche du thread dans le Vector et suppression

for (int i = 0; i < clients.size(); i++) {

ClientHandlerThread t = clients.get(i);

if (t.getId() == idThread) {

clients.remove(i);

System.out.println("Thread " + idThread + " supprimé du Vector");

break; // on sort de la boucle après suppression

}

}


}


}



Et le controleur notifiera ensuite de la reponse de retourAuthentification

C'est exactement la bonne approche pour gérer de l'asynchronisme. En utilisant VueClient comme pont, tu transformes ton interface en un système piloté par les événements (Event-Driven).

Voici comment structurer ton code pour que le contrôleur puisse notifier la vue une fois qu'il reçoit la réponse du serveur :
1. Adaptation de VueClient.java

Tu dois ajouter des méthodes de "retour" (callbacks) que le contrôleur appellera. Ces méthodes se chargeront de déclencher le changement d'état.
Java

// Dans VueClient.java
public void demanderAuthentification(String nom, String motDePasse) {
    this.controleur.demanderAuthentification(nom, motDePasse); 
}

// Cette méthode sera appelée par ton ControleurClient quand il recevra le paquet du serveur
public void retourAuthentification(boolean succes) {
    if (succes) {
        // Si la connexion réussit, on change l'état vers Connecté
        this.setEtat(new EtatConnecte(this));
    } else {
        // Optionnel : Afficher un message d'erreur sur le panel actuel
        System.out.println("Erreur d'authentification");
    }
}

2. Rôle du Controleur (Côté Client)

Ton ControleurClient (qui communique avec le ClientHandlerThread du serveur) doit posséder une référence vers la VueClient. Lorsqu'il reçoit une réponse sur son socket :

    Il analyse le message.

    Il appelle vue.retourAuthentification(true).

    Attention : Comme la réception réseau se fait souvent sur un thread séparé, il est prudent d'utiliser SwingUtilities.invokeLater() dans le contrôleur pour s'assurer que le changement d'état (qui modifie l'UI via changerAffichage) se fait sur le thread Java Swing.

3. Schéma de communication asynchrone
4. Pourquoi c'est "propre" ?

    Séparation des responsabilités : Les panels ne savent même pas que le réseau existe. Ils demandent juste une action à la vue.

    Fluidité : Ton interface ne "freeze" pas pendant que le serveur réfléchit, car le thread de l'interface (EDT) est libéré immédiatement après l'envoi de la requête.

    Centralisation : Si tu décides de changer la manière dont tu gères les erreurs de connexion, tu n'as qu'à modifier VueClient ou le contrôleur, pas tes 5 panels différents.

Prochaine étape suggérée

Veux-tu que je t'aide à rédiger la méthode de réception dans ton ControleurClient pour qu'elle traite la réponse du serveur et appelle correctement retourAuthentification ?

package Vue;


import javax.swing.JButton;

import javax.swing.JLabel;

import javax.swing.JPanel;

import javax.swing.JTextField;


import java.awt.GridLayout;

import java.awt.event.ActionEvent;

import java.awt.event.ActionListener;


public class PanelConnection extends JPanel{

VueClient vue;

JTextField nom;

JTextField motDePasse;


public PanelConnection(VueClient v){

this.vue = v;

this.nom = new JTextField(10);

this.motDePasse = new JTextField(10);


JButton boutonConnection = new JButton("Se connecter");

boutonConnection.addActionListener(new ActionListener() {

public void actionPerformed(ActionEvent e){

vue.demanderAuthentification(nom.getText(),motDePasse.getText());

}

});


GridLayout layout = new GridLayout(3,1);

this.setLayout(layout);


//Champs pour le nom

JPanel panelNom = new JPanel();

panelNom.setLayout(new GridLayout(1,2));

panelNom.add(new JLabel("Nom :"));

panelNom.add(this.nom);


//Champs pour le mot de passe

JPanel panelMotDePasse = new JPanel();

panelMotDePasse.setLayout(new GridLayout(1,2));

panelMotDePasse.add(new JLabel("Mot de passe :"));

panelMotDePasse.add(this.motDePasse);


this.add(panelNom);

this.add(panelMotDePasse);

this.add(boutonConnection);


}

}


Rend moi ca plus jolie. Des champs a la taille des label un bouton connection centré et redut

Pour rendre ton interface plus élégante sous Swing tout en respectant tes contraintes (champs alignés et bouton centré), je te conseille d'utiliser le GridBagLayout.

C'est le gestionnaire le plus puissant pour aligner des composants de tailles différentes tout en gardant un contrôle précis sur les marges et l'espacement.

Voici une version améliorée de ton PanelConnection :
Java

package Vue;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class PanelConnection extends JPanel {
    
    VueClient vue;
    JTextField nom;
    JPasswordField motDePasse; // Utilisation de JPasswordField pour la sécurité

    public PanelConnection(VueClient v) {
        this.vue = v;
        
        // Configuration du layout principal
        this.setLayout(new GridBagLayout());
        this.setBorder(new EmptyBorder(20, 20, 20, 20)); // Marges autour du panel
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(10, 10, 10, 10); // Espacement entre les composants
        gbc.fill = GridBagConstraints.HORIZONTAL;

        // Initialisation des champs
        this.nom = new JTextField(15);
        this.motDePasse = new JPasswordField(15);
        JButton boutonConnection = new JButton("Se connecter");

        // --- Ligne 1 : Nom ---
        gbc.gridx = 0; gbc.gridy = 0;
        this.add(new JLabel("Nom :"), gbc);
        
        gbc.gridx = 1;
        this.add(this.nom, gbc);

        // --- Ligne 2 : Mot de passe ---
        gbc.gridx = 0; gbc.gridy = 1;
        this.add(new JLabel("Mot de passe :"), gbc);
        
        gbc.gridx = 1;
        this.add(this.motDePasse, gbc);

        // --- Ligne 3 : Bouton (Centré et réduit) ---
        gbc.gridx = 0; gbc.gridy = 2;
        gbc.gridwidth = 2; // Prend les deux colonnes
        gbc.fill = GridBagConstraints.NONE; // Ne s'étire pas horizontalement
        gbc.anchor = GridBagConstraints.CENTER; // Centre le bouton
        
        boutonConnection.setPadding(new Insets(5, 20, 5, 20)); // Un peu de "souffle" dans le bouton
        this.add(boutonConnection, gbc);

        // Action
        boutonConnection.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                // Conversion du tableau de char en String pour le mot de passe
                String password = new String(motDePasse.getPassword());
                vue.demanderAuthentification(nom.getText(), password);
            }
        });
    }
}

Ce qui a été amélioré :

    GridBagLayout : Contrairement au GridLayout, il permet d'avoir des colonnes de largeurs différentes. Ici, la colonne des labels s'adapte à leur texte, et celle des champs prend le reste de la place.

    JPasswordField : Pour un champ de mot de passe, c'est la norme (affiche des points au lieu du texte clair).

    Espacements (Insets) : Ajout d'air entre les composants pour éviter qu'ils ne soient collés les uns aux autres.

    Bouton centré : Grâce à gbc.fill = GridBagConstraints.NONE et gbc.anchor = GridBagConstraints.CENTER, le bouton garde sa taille naturelle (réduite) et se place au milieu des deux colonnes.

    Marges (EmptyBorder) : Ajoute une marge de sécurité tout autour du panel pour que le contenu ne touche pas les bords de la fenêtre.

Prochaine étape suggérée :

Souhaites-tu que j'ajoute un mécanisme pour que la touche Entrée déclenche aussi la connexion, ou préfères-tu qu'on regarde comment gérer l'affichage d'un message d'erreur si l'authentification échoue ?

boutonConnection.setPadding(new Insets(5, 20, 5, 20)); // Un peu de "souffle" dans le bouton

on me demande un cast ?

Oups ! C'est ma faute, j'ai mélangé un peu de syntaxe CSS ou Android avec du Java Swing pur. La classe JButton n'a pas de méthode setPadding.

Pour ajouter de l'espace à l'intérieur d'un bouton en Swing, on utilise setMargin(Insets).

Voici la correction :
Java

// Remplace cette ligne :
// boutonConnection.setPadding(new Insets(5, 20, 5, 20)); 

// Par celle-ci :
boutonConnection.setMargin(new Insets(5, 20, 5, 20));

Pourquoi l'erreur ?

    setMargin définit l'espace entre le texte du bouton et sa bordure.

    Si tu voulais vraiment changer la taille du bouton de manière fixe (ce qui est moins flexible), tu aurais dû utiliser setPreferredSize(new Dimension(largeur, hauteur)). Mais setMargin est bien plus propre car il s'adapte à la police d'écriture.

Petit bonus ergonomie

Pour que ton interface soit vraiment agréable, tu peux ajouter cette ligne pour que la touche Entrée du clavier active le bouton automatiquement :
Java

// Dans le constructeur de ton PanelConnection
this.vue.frame.getRootPane().setDefaultButton(boutonConnection);

Est-ce que le layout s'affiche correctement maintenant avec le GridBagLayout ?

String password = new String(motDePasse.getPassword());

Et la

Cette ligne fonctionne parfaitement, mais elle souligne une petite particularité de Java Swing liée à la sécurité.

La méthode getPassword() d'un JPasswordField ne renvoie pas une String, mais un tableau de caractères (char[]). En faisant new String(...), tu convertis ce tableau en texte classique pour pouvoir l'envoyer à ton contrôleur.
Pourquoi ce n'est pas une String au départ ?

L'équipe de Java a fait ce choix pour des raisons de sécurité :

    Les Strings sont "immuables" et restent dans la mémoire de l'ordinateur jusqu'à ce que le ramasse-miettes (Garbage Collector) passe. Si quelqu'un scanne la mémoire vive, il pourrait y trouver le mot de passe en clair.

    Les tableaux de char[] peuvent être effacés manuellement (en remplaçant chaque case par un 0 par exemple) dès que tu n'en as plus besoin.

Est-ce grave dans ton cas ?

Comme tu es dans un projet d'apprentissage et que tu dois probablement envoyer cette information via un socket (qui finit souvent par transformer le tout en String ou en bytes), ta ligne est tout à fait correcte et ne devrait pas générer d'erreur de compilation.
Une petite astuce pour ton PanelConnection

Pour que ton code soit vraiment robuste, tu pourrais vérifier que les champs ne sont pas vides avant de contacter le contrôleur :
Java

boutonConnection.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent e){
        String user = nom.getText().trim();
        String pass = new String(motDePasse.getPassword());

        if(user.isEmpty() || pass.isEmpty()){
            JOptionPane.showMessageDialog(null, "Veuillez remplir tous les champs", "Erreur", JOptionPane.ERROR_MESSAGE);
        } else {
            vue.demanderAuthentification(user, pass);
        }
    }
});

Veux-tu que je t'aide à préparer la réception du message de succès ou d'échec dans ton ControleurClient pour fermer la boucle ?

mettre le texte d'un jlabel en couleur

Pour mettre du texte en couleur dans un JLabel, tu as deux approches principales selon tes besoins : la méthode simple (couleur uniforme) ou la méthode HTML (pour plus de fantaisie).
1. La méthode standard (Couleur uniforme)

Si tu veux que tout le texte du label soit de la même couleur, utilise la méthode setForeground(Color).
Java

JLabel label = new JLabel("Texte en rouge");
label.setForeground(Color.RED); // Utilise les constantes de java.awt.Color

Tu peux aussi créer une couleur personnalisée avec le code RGB :
Java

label.setForeground(new Color(34, 139, 34)); // Un joli vert "Forest Green"

2. La méthode HTML (Couleurs multiples ou spécifiques)

Swing supporte le rendu HTML de base. C'est très pratique si tu veux mélanger plusieurs couleurs dans un seul et même JLabel.
Java

JLabel label = new JLabel("<html>Le mot est <font color='blue'>bleu</font> et celui-là <font color='#FF4500'>orange</font></html>");

    Note : N'oublie pas de commencer et finir ton texte par les balises <html> et </html> pour que Swing interprète le code.

Application dans ton PanelConnection

Si tu veux, par exemple, mettre tes labels "Nom" et "Mot de passe" en gris foncé pour un look plus moderne :
Java

JLabel labelNom = new JLabel("Nom :");
labelNom.setForeground(new Color(60, 60, 60)); // Gris anthracite

// Ou via HTML pour ajouter une étoile rouge (champ obligatoire)
JLabel labelPass = new JLabel("<html>Mot de passe <font color='red'>*</font> :</html>");

Conseil bonus : Le contraste

Si tu changes la couleur du texte, assure-toi qu'elle reste lisible sur le fond de ton panel. Si ton panel est sombre, utilise Color.WHITE ou un gris très clair.

Est-ce que tu aimerais que je t'aide à créer un JLabel de retour (ex: un message d'erreur qui s'affiche en rouge en bas de ton formulaire) ?

package Vue;


import javax.swing.JFrame;

import javax.swing.JLabel;

import javax.swing.JPanel;


import java.awt.Color;

import java.awt.event.WindowAdapter;

import java.awt.event.WindowEvent;


import Controller.ControleurClient;

import Etat.Etat;

import Etat.EtatInit;


public class VueClient {

JFrame frame;

JPanel panel;

ControleurClient controleur;


Etat etat;


public VueClient(ControleurClient controleur){

this.controleur = controleur;

this.frame = new JFrame("Client Pacman");

this.frame.setSize(800,600);

//this.frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//Fermer l'application quand on clique sur la croix

this.frame.addWindowListener(new WindowAdapter() {

@Override

public void windowClosing(WindowEvent e) {

// Informe le controller que la fenêtre ferme

controleur.fermerConnexion(); // ferme proprement le socket, threads, etc.


frame.dispose();// remplace le EXIT_ON_CLOSE

}

});



this.etat = new EtatInit(this);



this.frame.setVisible(true);

}


public void setEtat(Etat etat){

this.etat = etat;

}

public Etat getEtat(){

return this.etat;

}


public void changerAffichage(JPanel panel){

if(this.panel != null){

this.frame.remove(this.panel);

}

this.panel = panel;

this.frame.add(this.panel);

this.frame.revalidate();

this.frame.repaint();

}


public void demanderAuthentification(String nom, String motDePasse){

this.controleur.demanderAuthentification(nom, motDePasse);

}


public void traiterAuthentification(boolean succes){

if(succes){

this.etat.seConnecter();

} else {

// Afficher un message d'erreur ou rester sur le même écran

System.out.println("Authentification échouée. Veuillez réessayer.");

JLabel label = new JLabel("Authentification échouée. Veuillez réessayer.");

label.setForeground(Color.RED);

this.panel.add(label, 0); // Affiche le message en haut du panel

this.panel.revalidate();

this.panel.repaint();

}

}

}


Comment avoir un JLabel d'erreur qui ne se stack pas (disparait qaund le nouveau arrive) et se met bien en haut

Pour éviter que tes messages d'erreur ne s'empilent et pour garantir qu'ils s'affichent correctement en haut de ton interface, l'approche la plus propre consiste à déclarer un JLabel dédié dans ton panel plutôt que d'en créer un nouveau à chaque échec.

Voici comment modifier ton code pour gérer cela proprement :
1. Préparer le PanelConnection

Il est préférable que le panel possède déjà le label d'erreur dans sa structure. Comme tu utilises un GridBagLayout, on lui réserve une place tout en haut.
Java

public class PanelConnection extends JPanel {
    // ... tes autres attributs
    private JLabel labelErreur;

    public PanelConnection(VueClient v) {
        // ... ta configuration GridBagLayout
        
        this.labelErreur = new JLabel(" "); // Un espace vide pour garder la place
        this.labelErreur.setForeground(Color.RED);
        this.labelErreur.setHorizontalAlignment(SwingConstants.CENTER);

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0; // Ligne 0
        gbc.gridwidth = 2;
        gbc.insets = new Insets(5, 0, 10, 0);
        this.add(labelErreur, gbc);

        // Les autres champs (Nom, MDP) commenceront à gbc.gridy = 1
        // ...
    }

    public void afficherMessageErreur(String message) {
        this.labelErreur.setText(message);
    }
}

2. Modifier traiterAuthentification dans VueClient

Au lieu d'ajouter un nouveau composant au panel (ce qui casse le layout et s'empile), on met simplement à jour le texte du label existant.
Java

public void traiterAuthentification(boolean succes){
    if(succes){
        this.etat.seConnecter();
    } else {
        // On vérifie si le panel actuel est bien celui de connexion
        if (this.panel instanceof PanelConnection) {
            ((PanelConnection) this.panel).afficherMessageErreur("Authentification échouée. Veuillez réessayer.");
        }
        
        // On force quand même le rafraîchissement visuel
        this.frame.revalidate();
        this.frame.repaint();
    }
}

Pourquoi c'est mieux ainsi ?

    Pas de "Stacking" : Tu ne fais que modifier le contenu d'un objet existant. Le texte précédent est écrasé par le nouveau.

    Stabilité du Layout : En initialisant le label avec un espace " ", tu réserves la place. Cela évite que tes champs de saisie ne "sautent" vers le bas quand l'erreur apparaît.

    Performance : Ajouter/Supprimer des composants Swing est plus coûteux que de simplement changer un texte.

Alternative rapide (si tu ne veux pas modifier le Panel)

Si tu veux rester sur ta logique actuelle sans toucher aux classes des panels, tu dois identifier le label pour le supprimer avant d'en ajouter un nouveau :
Java

public void traiterAuthentification(boolean succes){
    if(succes){
        this.etat.seConnecter();
    } else {
        // Supprime l'ancien message s'il existe (via un nom ou un tag)
        for (Component c : this.panel.getComponents()) {
            if (c.getName() != null && c.getName().equals("errorLabel")) {
                this.panel.remove(c);
            }
        }

        JLabel label = new JLabel("Authentification échouée.");
        label.setName("errorLabel"); // On lui donne un nom pour le retrouver
        label.setForeground(Color.RED);
        
        this.panel.add(label, 0); // Toujours en haut
        this.panel.revalidate();
        this.panel.repaint();
    }
}

Ma recommandation : Utilise la première méthode. C'est beaucoup plus robuste de laisser le Panel gérer son propre affichage d'erreurs.

Souhaites-tu que je te montre comment vider automatiquement ce message d'erreur dès que l'utilisateur recommence à taper dans les champs ?

package Vue;


import javax.swing.JButton;

import javax.swing.JLabel;

import javax.swing.JPanel;

import javax.swing.JPasswordField;

import javax.swing.JTextField;

import javax.swing.SwingConstants;

import javax.swing.border.EmptyBorder;


import java.awt.Color;

import java.awt.GridBagConstraints;

import java.awt.GridBagLayout;

import java.awt.Insets;

import java.awt.event.ActionEvent;

import java.awt.event.ActionListener;


public class PanelConnection extends JPanel{

VueClient vue;

JTextField nom;

JPasswordField motDePasse;

private JLabel labelErreur;



public PanelConnection(VueClient v){

this.vue = v;

// Configuration du layout principal

this.setLayout(new GridBagLayout());

this.setBorder(new EmptyBorder(20, 20, 20, 20)); // Marges autour du panel

GridBagConstraints gbc = new GridBagConstraints();

gbc.insets = new Insets(10, 10, 10, 10); // Espacement entre les composants

gbc.fill = GridBagConstraints.HORIZONTAL;


this.labelErreur = new JLabel(" "); // Un espace vide pour garder la place

this.labelErreur.setForeground(Color.RED);

this.labelErreur.setHorizontalAlignment(SwingConstants.CENTER);

gbc.gridx = 0;

gbc.gridy = 0; // Ligne 0

gbc.gridwidth = 2;

gbc.insets = new Insets(5, 0, 10, 0);

this.add(labelErreur, gbc);



// Initialisation des champs

this.nom = new JTextField(15);

this.motDePasse = new JPasswordField(15);

JButton boutonConnection = new JButton("Se connecter");


// --- Ligne 1 : Nom ---

gbc.gridx = 0; gbc.gridy = 1;

this.add(new JLabel("Nom :"), gbc);

gbc.gridx = 1;

this.add(this.nom, gbc);


// --- Ligne 2 : Mot de passe ---

gbc.gridx = 0; gbc.gridy = 2;

this.add(new JLabel("Mot de passe :"), gbc);

gbc.gridx = 1;

this.add(this.motDePasse, gbc);


// --- Ligne 3 : Bouton (Centré et réduit) ---

gbc.gridx = 0; gbc.gridy = 3;

gbc.gridwidth = 2; // Prend les deux colonnes

gbc.fill = GridBagConstraints.NONE; // Ne s'étire pas horizontalement

gbc.anchor = GridBagConstraints.CENTER; // Centre le bouton

boutonConnection.setMargin(new Insets(5, 20, 5, 20));

this.add(boutonConnection, gbc);


// Action

boutonConnection.addActionListener(new ActionListener() {

public void actionPerformed(ActionEvent e) {

// Conversion du tableau de char en String pour le mot de passe

String password = new String(motDePasse.getPassword());

vue.demanderAuthentification(nom.getText(), password);

}

});


}

public void afficherMessageErreur(String message) {

this.labelErreur.setText(message);

}


}

Ton PanelConnection est maintenant très propre et suit une architecture robuste. En ayant intégré le labelErreur directement dans le GridBagLayout à la ligne 0, tu assures une stabilité visuelle : l'interface ne "bougera" pas lorsque l'erreur apparaîtra car la place est déjà réservée par l'espace vide " ".

Voici deux petites optimisations pour parfaire l'expérience utilisateur :
1. Correction du GridBagConstraints

Dans ton code actuel, après avoir ajouté le labelErreur, les gbc conservent gridwidth = 2. Il est préférable de le remettre à 1 pour les lignes suivantes afin que le label "Nom :" et le champ nom soient bien sur deux colonnes distinctes.
Java

// --- Ligne 1 : Nom ---
gbc.gridx = 0; gbc.gridy = 1;
gbc.gridwidth = 1; // <--- AJOUTER CECI pour revenir à une seule colonne par composant
gbc.fill = GridBagConstraints.HORIZONTAL; // <--- S'assurer que le champ s'étire
this.add(new JLabel("Nom :"), gbc);

gbc.gridx = 1;
this.add(this.nom, gbc);

2. Effacer l'erreur lors de la saisie

Pour un côté "pro", on peut effacer le message rouge dès que l'utilisateur commence à corriger ses identifiants. Tu peux ajouter un DocumentListener sur tes champs :
Java

// Exemple à ajouter dans ton constructeur pour le champ 'nom'
this.nom.getDocument().addDocumentListener(new javax.swing.event.DocumentListener() {
    public void insertUpdate(javax.swing.event.DocumentEvent e) { effacer(); }
    public void removeUpdate(javax.swing.event.DocumentEvent e) { effacer(); }
    public void changedUpdate(javax.swing.event.DocumentEvent e) { effacer(); }
    private void effacer() { labelErreur.setText(" "); }
});

Résumé de l'interaction Vue-État-Contrôleur

Avec ce fichier, ton flux est désormais complet :

    PanelConnection : Capture les saisies et appelle vue.demanderAuthentification().

    VueClient : Transmet au ControleurClient.

    ControleurClient : Reçoit la réponse du serveur (asynchrone) et appelle vue.traiterAuthentification(succes).

    VueClient :

        Si succes, appelle etat.seConnecter() (qui change l'affichage vers PanelRejoindrePartie).

        Si echec, appelle panel.afficherMessageErreur().

Souhaites-tu que l'on s'attaque maintenant au PanelRejoindrePartie ou à la logique de réception des messages dans ton ControleurClient ?

package Vue;


import javax.swing.JFrame;

import javax.swing.JLabel;

import javax.swing.JPanel;


import java.awt.Color;

import java.awt.event.WindowAdapter;

import java.awt.event.WindowEvent;


import Controller.ControleurClient;

import Etat.Etat;

import Etat.EtatInit;


public class VueClient {

JFrame frame;

JPanel panel;

ControleurClient controleur;


Etat etat;


public VueClient(ControleurClient controleur){

this.controleur = controleur;

this.frame = new JFrame("Client Pacman");

this.frame.setSize(800,600);

//this.frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//Fermer l'application quand on clique sur la croix

this.frame.addWindowListener(new WindowAdapter() {

@Override

public void windowClosing(WindowEvent e) {

// Informe le controller que la fenêtre ferme

controleur.fermerConnexion(); // ferme proprement le socket, threads, etc.


frame.dispose();// remplace le EXIT_ON_CLOSE

}

});



this.etat = new EtatInit(this);



this.frame.setVisible(true);

}


public void setEtat(Etat etat){

this.etat = etat;

}

public Etat getEtat(){

return this.etat;

}


public void changerAffichage(JPanel panel){

if(this.panel != null){

this.frame.remove(this.panel);

}

this.panel = panel;

this.frame.add(this.panel);

this.frame.revalidate();

this.frame.repaint();

}


public void demanderAuthentification(String nom, String motDePasse){

this.controleur.demanderAuthentification(nom, motDePasse);

}


public void traiterAuthentification(boolean succes){

if(succes){

this.etat.seConnecter();

} else {

// Afficher un message d'erreur ou rester sur le même écran

System.out.println("Authentification échouée. Veuillez réessayer.");

this.panel.afficherMessageErreur("Authentification échouée. Veuillez réessayer.");

this.panel.revalidate();

this.panel.repaint();

}

}

}


Probleme de polymorphisme

L'erreur vient du fait que dans ta classe VueClient, l'attribut panel est déclaré comme un simple JPanel. Or, la classe JPanel de base ne possède pas la méthode afficherMessageErreur.

Même si au moment de l'exécution (runtime) ton panel est bien un PanelConnection, le compilateur Java, lui, ne voit que le type déclaré (JPanel).

Voici comment régler ce problème de polymorphisme proprement :
1. La solution par "Cast" (La plus rapide)

Tu forces le compilateur à considérer le panel comme un PanelConnection uniquement si c'est réellement le cas.
Java

public void traiterAuthentification(boolean succes){
    if(succes){
        this.etat.seConnecter();
    } else {
        // On vérifie si le panel actuel est bien une instance de PanelConnection
        if (this.panel instanceof PanelConnection) {
            // On "cast" (convertit) explicitement pour accéder à la méthode
            ((PanelConnection) this.panel).afficherMessageErreur("Authentification échouée.");
        }
        this.frame.revalidate();
        this.frame.repaint();
    }
}

2. La solution par "Interface" (La plus propre)

Si tu prévois d'avoir d'autres écrans qui affichent des erreurs (ex: PanelRejoindrePartie si le salon est plein), le cast ne suffira plus. Le mieux est de créer une interface.

Étape A : Créer l'interface
Java

public interface PanelAvertisseur {
    void afficherMessageErreur(String message);
}

Étape B : L'implémenter dans tes Panels
Java

public class PanelConnection extends JPanel implements PanelAvertisseur {
    // ... ton code existant ...
    @Override
    public void afficherMessageErreur(String message) {
        this.labelErreur.setText(message);
    }
}

Étape C : L'utiliser dans VueClient
Java

public void traiterAuthentification(boolean succes){
    if(succes){
        this.etat.seConnecter();
    } else {
        if (this.panel instanceof PanelAvertisseur) {
            ((PanelAvertisseur) this.panel).afficherMessageErreur("Erreur...");
        }
    }
}

Pourquoi c'est important ?

Le polymorphisme permet à VueClient de manipuler n'importe quel panel sans connaître son type exact. En utilisant une interface comme PanelAvertisseur, tu dis à ton code : "Je ne sais pas quel panel est affiché, mais je sais qu'il est capable d'afficher une erreur".
Un dernier détail dans ton code

Regarde bien ton constructeur VueClient :
Java

public VueClient(ControleurClient controleur){
    this.controleur = controleur; // Assure-toi que cette ligne est bien présente
    // ...

Dans ton message précédent, le this.controleur = controleur; manquait parfois, ce qui causerait une NullPointerException lors de l'appel à demanderAuthentification.

Quelle solution préfères-tu mettre en place ? Le Cast (simple) ou l'Interface (évolutif) ?

cast et instance of pas tres propre.

Je suis d'accord avec toi : le instanceof et le cast sont souvent considérés comme des "odeurs de code" (code smells) car ils brisent le principe d'encapsulation. Si tu ajoutes 10 nouveaux panels, ton VueClient va devenir une forêt de if/else.

Pour rendre cela vraiment propre, la solution standard en design pattern est d'utiliser une Interface ou une Classe Abstraite pour tes panels.

Voici comment transformer ton architecture pour qu'elle soit élégante et évolutive.
1. Créer une interface commune

On crée un contrat que tous tes panels "intelligents" devront suivre.
Java

package Vue;

public interface MonPanel {
    // Par défaut, un panel ne fait rien, mais il peut être surchargé
    default void afficherMessageErreur(String message) {
        // Optionnel : log ou rien du tout
    }
}

2. Modifier tes Panels

Maintenant, tes panels implémentent cette interface.
Java

public class PanelConnection extends JPanel implements MonPanel {
    // ... ton code ...
    
    @Override
    public void afficherMessageErreur(String message) {
        this.labelErreur.setText(message);
    }
}

3. La magie dans VueClient

Dans VueClient, au lieu de déclarer JPanel panel;, tu vas déclarer ton interface.
Java

public class VueClient {
    JFrame frame;
    MonPanel panel; // On utilise l'interface ici !
    
    // ...
    
    public void changerAffichage(JPanel nouveauPanel) {
        if(this.panel != null) {
            this.frame.remove((JPanel)this.panel);
        }
        
        // On stocke le nouveau panel en tant que MonPanel
        if (nouveauPanel instanceof MonPanel) {
            this.panel = (MonPanel) nouveauPanel;
        }
        
        this.frame.add(nouveauPanel);
        this.frame.revalidate();
        this.frame.repaint();
    }

    public void traiterAuthentification(boolean succes) {
        if(succes) {
            this.etat.seConnecter();
        } else {
            // Plus besoin de savoir quel panel c'est ! 
            // S'il implémente MonPanel, il recevra l'erreur.
            this.panel.afficherMessageErreur("Erreur d'authentification");
        }
    }
}

Pourquoi c'est beaucoup plus propre ?

    Inversion de contrôle : VueClient n'a plus besoin de connaître l'existence de PanelConnection. Il sait juste qu'il manipule un objet capable de "gérer une erreur".

    Évolutivité : Demain, si tu crées un PanelRejoindrePartie et que la connexion échoue, il te suffit de lui faire implémenter MonPanel et d'écrire sa méthode afficherMessageErreur. Tu ne toucheras pas une seule ligne de VueClient.

    Utilisation des default methods : En utilisant default dans l'interface (Java 8+), tes panels simples (comme un écran de crédits) n'ont même pas besoin d'écrire la méthode s'ils n'en ont pas l'utilité.

    Shutterstock

Une alternative encore plus "pure" :

Si tu veux éviter le cast même dans changerAffichage, tu peux créer une classe de base : public abstract class MonBasePanel extends JPanel implements MonPanel { ... } Et faire hériter tous tes panels de MonBasePanel. Ainsi, ton attribut dans VueClient sera directement du bon type.

Est-ce que cette approche par interface te semble plus satisfaisante pour ton projet ?

On peux peut etre le mettre en haut de la frame

C'est une excellente idée ! En mettant le label d'erreur directement dans la Frame (ou dans un conteneur fixe en haut), tu sépares complètement l'affichage des messages système du contenu changeant des panels.

Cela résout trois problèmes d'un coup :

    Stabilité : Les panels ne bougent plus quand une erreur arrive.

    Visibilité : Le message reste au même endroit, peu importe l'écran.

    Polymorphisme : Tu n'as plus besoin de demander aux panels d'afficher l'erreur, c'est la VueClient qui gère son propre label.

Voici comment mettre cela en place :
1. Modifier VueClient.java

On va changer le layout de la JFrame pour un BorderLayout. Le label d'erreur sera au NORTH et les panels au CENTER.
Java

public class VueClient {
    JFrame frame;
    JPanel panelCourant; // Pour garder une trace du panel central
    JLabel labelErreur;
    ControleurClient controleur;
    Etat etat;

    public VueClient(ControleurClient controleur){
        this.controleur = controleur;
        this.frame = new JFrame("Client Pacman");
        this.frame.setSize(800,600);
        
        // Utilisation du BorderLayout pour séparer le haut du centre
        this.frame.setLayout(new java.awt.BorderLayout());

        // Création du label d'erreur fixe
        this.labelErreur = new JLabel(" "); // Espace pour garder la hauteur
        this.labelErreur.setForeground(Color.RED);
        this.labelErreur.setHorizontalAlignment(SwingConstants.CENTER);
        this.labelErreur.setFont(new Font("Arial", Font.BOLD, 14));
        
        // Ajout du label en haut (NORTH)
        this.frame.add(labelErreur, java.awt.BorderLayout.NORTH);

        this.etat = new EtatInit(this);
        this.frame.setVisible(true);
    }

    public void changerAffichage(JPanel nouveauPanel){
        if(this.panelCourant != null){
            this.frame.remove(this.panelCourant);
        }
        // On remet le message à vide à chaque changement d'écran
        this.labelErreur.setText(" "); 
        
        this.panelCourant = nouveauPanel;
        this.frame.add(this.panelCourant, java.awt.BorderLayout.CENTER);
        
        this.frame.revalidate();
        this.frame.repaint();
    }

    public void traiterAuthentification(boolean succes){
        if(succes){
            this.etat.seConnecter();
        } else {
            // On écrit directement sur le label de la VueClient
            this.labelErreur.setText("Authentification échouée. Veuillez réessayer.");
        }
    }
}

2. Pourquoi c'est l'approche la plus robuste ?

    Zéro couplage : Tes fichiers PanelConnection.java, PanelRejoindrePartie.java, etc., n'ont plus besoin de savoir qu'un système d'erreur existe. Ils se contentent d'afficher leurs boutons et champs.

    Centralisation : Si tu veux changer la police des messages d'erreur ou ajouter une icône d'alerte, tu ne le fais qu'à un seul endroit : dans VueClient.

    Nettoyage automatique : Dans changerAffichage, j'ai ajouté un setText(" "). Cela garantit que si l'utilisateur change de page, l'ancienne erreur disparaît.

Petit conseil de finition

Pour que ce soit encore plus propre, tu pourrais ajouter une petite marge (Padding) en haut pour que le texte ne colle pas au bord de la fenêtre :
Java

this.labelErreur.setBorder(new javax.swing.border.EmptyBorder(10, 0, 10, 0));

Est-ce que cette disposition te convient mieux visuellement ? On peut aussi imaginer une barre de statut en bas (SOUTH) si tu préfères !

^Cetud@port-hp-elitebook650G10-11:~/Ecole/Fac/M1/Cours/ProgReseau/Projet/ClientPacman$ tree

*.

├── bin

│   ├── ClientPacman.class

│   ├── Controller

│   │   └── ControleurClient.class

│   ├── Etat

│   │   ├── Etat.class

│   │   ├── EtatConnecte.class

│   │   ├── EtatEnAttentePartie.class

│   │   ├── EtatEnJeu.class

│   │   ├── EtatInit.class

│   │   └── EtatJeuFini.class

│   ├── Reseau

│   │   ├── ExpediteurClient.class

│   │   └── RecepteurClient.class

│   └── Vue

│       ├── PanelAttentePartie$1.class

│       ├── PanelAttentePartie.class

│       ├── PanelConnection$1.class

│       ├── PanelConnection.class

│       ├── PanelEnJeu$1.class

│       ├── PanelEnJeu.class

│       ├── PanelFinPartie$1.class

│       ├── PanelFinPartie.class

│       ├── PanelRejoindrePartie$1.class

│       ├── PanelRejoindrePartie.class

│       ├── VueClient$1.class

│       └── VueClient.class

├── lib

│   └── json-20231013.jar

├── README.md

└── src

    ├── ClientPacman.java

    ├── Controller

    │   └── ControleurClient.java

    ├── Etat

    │   ├── EtatConnecte.java

    │   ├── EtatEnAttentePartie.java

    │   ├── EtatEnJeu.java

    │   ├── EtatInit.java

    │   ├── Etat.java

    │   └── EtatJeuFini.java

    ├── Reseau

    │   ├── ExpediteurClient.java

    │   └── RecepteurClient.java

    └── Vue

        ├── PanelAttentePartie.java

        ├── PanelConnection.java

        ├── PanelEnJeu.java

        ├── PanelFinPartie.java

        ├── PanelRejoindrePartie.java

        └── VueClient.java


12 directories, 40 files


Fait un gitignore pour le /.vscode le /lib et /bin

Voici un fichier .gitignore adapté à la structure de ton projet. Il permet de garder ton dépôt propre en ignorant les fichiers compilés, les bibliothèques externes et les configurations spécifiques à ton éditeur.
Extrait de code

# --- Compilation ---
# Ignore le dossier bin qui contient les fichiers .class
/bin/

# --- Bibliothèques ---
# Ignore les dépendances externes (souvent gérées à part ou via un outil de build)
/lib/

# --- IDE (VS Code) ---
# Ignore les configurations personnelles de l'éditeur
/.vscode/

# --- Divers ---
# Ignore les logs ou fichiers temporaires du système
*.log
.DS_Store
